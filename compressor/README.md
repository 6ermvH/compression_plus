# Анализ избыточности кода Хаффмана

Проект для исследования эффективности алгоритма сжатия Хаффмана с целью анализа избыточности кодирования в сравнении с теоретическими пределами.

## Структура проекта

```
compressor/
├── include/          # Заголовочные файлы C++
│   ├── bor.hpp       # Реализация дерева Хаффмана
│   └── compressor.hpp # Интерфейс компрессора
├── src/              # Исходный код C++
│   ├── bor.cpp       # Реализация дерева Хаффмана
│   ├── compressor.cpp # Алгоритм сжатия
│   └── main.cpp      # Точка входа C++ программы
├── obj/              # Объектные файлы (создаются при компиляции)
├── data/             # Директория с тестовыми данными
├── main              # Исполняемый файл компрессора
├── redundancy_analysis.go # Go-скрипт для анализа избыточности
```

## Теоретическая основа

Избыточность (redundancy) кода Хаффмана измеряет, насколько средняя длина кода превышает энтропию источника. Для двоичного источника с вероятностями символов p и (1-p), избыточность вычисляется как:

```
R = L - H(p)
```

где:
- R - избыточность кода
- L - средняя длина кода (бит на символ)
- H(p) - энтропия источника = -p·log₂(p) - (1-p)·log₂(1-p)

Галлагер доказал, что избыточность кода Хаффмана ограничена следующим образом:

```
R ≤ H(p) + p_max - 1 + log₂(e)/e
```

где p_max - наибольшая вероятность символа в исходном распределении.

## Компоненты проекта

### C++ компрессор
Ядро проекта реализовано на C++ и включает:
- Класс `Compressor` для сжатия текстовых файлов
- Класс `Tbor` для построения и использования дерева Хаффмана
- Утилиты для обработки ввода/вывода

### Go-скрипт для анализа избыточности
Утилита написанная на Go для:
- Генерации тестовых файлов с заданным распределением вероятностей символов
- Автоматического запуска компрессора с различными параметрами
- Анализа результатов и сравнения с теоретическими пределами
- Агрегирования результатов в CSV-файлы для дальнейшего анализа

## Как использовать

### Сборка проекта
```bash
make clean && make
```

### Запуск анализа избыточности
```bash
go run redundancy_analysis.go
# или
go build redundancy_analysis.go
./redundancy_analysis
```

### Параметры анализа (настраиваются в коде)
- `fileSize`: размер тестовых файлов в байтах
- `experiments`: количество экспериментов для каждого значения p1
- По умолчанию анализ проводится для p1 от 0.1 до 0.9 с шагом 0.1

## Результаты

Анализ генерирует два CSV-файла:
1. `results_[session_id].csv` - содержит результаты каждого эксперимента
2. `summary_[session_id].csv` - содержит усредненные результаты по всем экспериментам

Основные метрики:
- `p1` - вероятность символа 'A'
- `AvgRedundancy` - средняя избыточность кода Хаффмана
- `AvgGallagerBound` - среднее значение границы Галлагера
- `Difference` - разница между избыточностью и границей Галлагера

## Интерпретация результатов

Результаты показывают, что:

1. Избыточность кода Хаффмана наибольшая при экстремальных значениях p1 (0.1 и 0.9)
2. Наименьшая избыточность наблюдается при p1 около 0.3 и 0.7
3. Во всех случаях избыточность ниже границы Галлагера, что соответствует теоретическим ожиданиям
4. Разница между фактической избыточностью и границей Галлагера минимальна при p1 = 0.5

Это подтверждает, что код Хаффмана наиболее эффективен для источников с равномерным распределением вероятностей, и менее эффективен для сильно асимметричных распределений.

## Примеры результатов

Типичный результат анализа (p1, избыточность, граница Галлагера):

```
0.1, 0.657084, 0.899733
0.2, 0.501112, 1.052666
0.3, 0.443189, 1.112029
0.4, 0.449529, 1.101688
0.5, 0.516800, 1.030738
0.6, 0.446649, 1.101688
0.7, 0.448629, 1.112029
0.8, 0.503992, 1.052666
0.9, 0.654524, 0.899733
```

Примечательно, что при p1 = 0.1 и p1 = 0.9 (симметричные случаи) фактическая избыточность значительно ниже границы Галлагера, что указывает на существование более точной верхней границы для этих случаев.
